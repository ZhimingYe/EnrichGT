#' @title Return ranked gene list which is use for "GSEA" and "cnetplot" in package "clusterProfiler"
#'
#' @param Gene A vector containing genes
#' @param log2FC A vector containg log2FC
#' @param FromType default is "SYMBOL"
#' @param OrgDB default as org.Hs.eg.db
#'
#' @return A ranked named numeric vector. Names of the numbers is the ENTREZID.
#' @export
#' @author Zhiming Ye
#'
Ranked.GS<-function(Gene,log2FC,FromType = "SYMBOL",OrgDB=org.Hs.eg.db){
  Genetable<-data.frame(Gene=Gene,log2FC=log2FC)
  require(clusterProfiler)
  ENTREZIDtable<-clusterProfiler::bitr(Genetable$Gene,fromType = FromType,toType = "ENTREZID",OrgDb = OrgDB)
  colnames(ENTREZIDtable)[1]<-"Gene"
  Genetable<-Genetable|>dplyr::left_join(ENTREZIDtable)|>dplyr::arrange(desc(log2FC))
  GSElist<-as.numeric(Genetable$log2FC)
  names(GSElist)<-Genetable$ENTREZID
  GSElist = sort(GSElist, decreasing = TRUE)
  return(GSElist)
}
#' @title ORA GO analysis by clusterProfiler by symbol identifiers.
#'
#' @param GS Gene Symbols for enrichment analysis. NOT ENSEMBL ID.
#' @param ont One of "BP", "CC", "MF"  and "ALL".
#' @param PVal P adjusted value cut off, default 0.01
#' @param QVal qvalue cut off, default 0.05
#' @param OrgDB default as org.Hs.eg.db
#'
#' @return An enrichment result generated by clusterProfiler.
#' @export
#' @author Zhiming Ye
#'
doGO<-function(GS,ont="BP",PVal=0.01,QVal=0.05,OrgDB=org.Hs.eg.db){
  require(clusterProfiler)
  GeneList<-GS|>unique()|>clusterProfiler::bitr(fromType = "SYMBOL",toType = "ENTREZID",OrgDb = OrgDB)
  EnrichGO<-clusterProfiler::enrichGO(GeneList$ENTREZID,ont = ont,OrgDb = OrgDB,pvalueCutoff = PVal,qvalueCutoff = QVal)|>clusterProfiler::setReadable(OrgDb=OrgDB,keyType = "ENTREZID")
  return(EnrichGO)
}
#' @title ORA KEGG analysis by clusterProfiler by symbol identifiers.
#'
#' @param GS Gene Symbols for enrichment analysis. NOT ENSEMBL ID.
#' @param PVal P adjusted value cut off, default 0.01
#' @param QVal qvalue cut off, default 0.05
#' @param Organism supported organism listed in 'https://www.genome.jp/kegg/catalog/org_list.html'
#' @param OrgDB default as org.Hs.eg.db
#'
#' @return An enrichment result generated by clusterProfiler.
#' @export
#' @author Zhiming Ye
#'
doKEGG<-function(GS,PVal=0.01,QVal=0.05,Organism="hsa",OrgDB=org.Hs.eg.db){
  require(clusterProfiler)
  GeneList<-GS|>unique()|>clusterProfiler::bitr(fromType = "SYMBOL",toType = "ENTREZID",OrgDb = OrgDB)
  EnrichKEGG<-clusterProfiler::enrichKEGG(GeneList$ENTREZID,pvalueCutoff = PVal,qvalueCutoff = QVal,organism=Organism)|>clusterProfiler::setReadable(OrgDb=OrgDB,keyType = "ENTREZID")
  return(EnrichKEGG)
}
#' @title ORA Reactome analysis by clusterProfiler by symbol identifiers.
#'
#' @param GS Gene Symbols for enrichment analysis. NOT ENSEMBL ID.
#' @param PVal P adjusted value cut off, default 0.01
#' @param QVal qvalue cut off, default 0.05
#' @param Organism one of "human", "rat", "mouse", "celegans", "yeast", "zebrafish", "fly".
#' @param OrgDB default as org.Hs.eg.db
#'
#' @return An enrichment result generated by clusterProfiler.
#' @export
#' @author Zhiming Ye
#'
doRA<-function(GS,PVal=0.01,QVal=0.05,Organism="human",OrgDB=org.Hs.eg.db){
  require(clusterProfiler)
  require(ReactomePA)
  GeneList<-GS|>unique()|>clusterProfiler::bitr(fromType = "SYMBOL",toType = "ENTREZID",OrgDb = OrgDB)
  EnrichRA<-ReactomePA::enrichPathway(GeneList$ENTREZID,pvalueCutoff = PVal,qvalueCutoff = QVal,organism=Organism)|>clusterProfiler::setReadable(OrgDb=OrgDB,keyType = "ENTREZID")
  return(EnrichRA)
}
#' @title Build up a DEG data frame for clusterProfiler multi-group ORA analysis
#' @description Convert symbol, and add up group name in column.
#' @param Gene A vector containing genes.
#' @param Group A character of group name
#' @param OrgDB Default as org.Hs.eg.db
#'
#' @return A data frame. Following rbind command can help you build up the full DEG list.
#' @export
#' @author Zhiming Ye
#'
BuildMultigroupDEGlist<-function(Gene,Group,OrgDB=org.Hs.eg.db){
  require(clusterProfiler)
  Genetable <- data.frame(Gene = Gene, Group = Group)
  ENTREZIDtable <- clusterProfiler::bitr(Genetable$Gene, fromType = "SYMBOL",
                                         toType = "ENTREZID", OrgDb = OrgDB)
  colnames(ENTREZIDtable)[1] <- "Gene"
  Genetable <- Genetable |> left_join(ENTREZIDtable)
  return(Genetable)
}


# gmt file reader is cited from Yu lab's gson package. Author: Guangchuang Yu
# https://github.com/YuLab-SMU/gson/blob/main/R/GMT.R

##' parse gmt file to a data.frame
##'
##' @title getGMTFile
##' @description
##' read `.gmt` files
##'
##' @param gmtfile gmt file
##' @importFrom utils stack
##' @export
##' @return data.frame
##' @author cited from https://github.com/YuLab-SMU/gson/blob/main/R/GMT.R
getGMTFile <- function (gmtfile) {
  x <- readLines(gmtfile)
  res <- strsplit(x, "\t")
  names(res) <- vapply(res, function(y) y[1], character(1))
  res <- lapply(res, "[", -c(1:2))
  ont2gene <- stack(res)
  ont2gene <- ont2gene[, c("ind", "values")]
  colnames(ont2gene) <- c("term", "gene")
  return(ont2gene)
}


#' A C++ accelerated universal enrichment analyzer
#'
#' @param genes a vector of gene id
#' @param database a database
#' @param p_adj_methods one of "holm", "hochberg", "hommel", "bonferroni", "BH", "BY", "fdr", "none"
#' @param p_val_cut_off adjusted pvalue cutoff on enrichment tests to report
#' @param background_genes background genes. If missing, the all genes listed in the database
#' @param min_geneset_size minimal size of genes annotated for testing
#' @param max_geneset_size maximal size of genes annotated for testing
#'
#' @returns
#' @export
#' @examples
doEnrich <- function(genes,database,p_adj_methods="BH",p_val_cut_off=0.5,background_genes=NULL,min_geneset_size=10,max_geneset_size=500,multi_cores=0){
  if(is.character(genes)){
    result <- doEnrich_Internal(genes,database,p_adj_methods,p_val_cut_off,background_genes,min_geneset_size,max_geneset_size)
  }else if(is.list(genes)&multi_cores<=1){
    result <- lapply(genes,function(x){
      tryCatch({
        res <- doEnrich_Internal(genes=x,database,p_adj_methods,p_val_cut_off,background_genes,min_geneset_size,max_geneset_size)
        return(res)
      },error=function(e){
        return(data.frame(ERROR=e))
      })
    })
  }else if(is.list(genes)&multi_cores>=2){
    require(parallel)
    result <- mclapply(genes,function(x){
      tryCatch({
        res <- doEnrich_Internal(genes=x,database,p_adj_methods,p_val_cut_off,background_genes,min_geneset_size,max_geneset_size)
        return(res)
      },error=function(e){
        return(data.frame(ERROR=e))
      })
    },mc.cores = multi_cores)
  }
  return(result)
}
